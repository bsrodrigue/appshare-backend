// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: application_releases.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkReleaseExists = `-- name: CheckReleaseExists :one
SELECT EXISTS (
    SELECT 1 FROM application_releases
    WHERE application_id = $1 AND version_code = $2 AND environment = $3 AND deleted_at IS NULL
)
`

type CheckReleaseExistsParams struct {
	ApplicationID pgtype.UUID        `json:"application_id"`
	VersionCode   int32              `json:"version_code"`
	Environment   ReleaseEnvironment `json:"environment"`
}

func (q *Queries) CheckReleaseExists(ctx context.Context, arg CheckReleaseExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkReleaseExists, arg.ApplicationID, arg.VersionCode, arg.Environment)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createApplicationRelease = `-- name: CreateApplicationRelease :one
INSERT INTO application_releases (
    title,
    version_code,
    version_name,
    release_note,
    environment,
    application_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type CreateApplicationReleaseParams struct {
	Title         string             `json:"title"`
	VersionCode   int32              `json:"version_code"`
	VersionName   string             `json:"version_name"`
	ReleaseNote   pgtype.Text        `json:"release_note"`
	Environment   ReleaseEnvironment `json:"environment"`
	ApplicationID pgtype.UUID        `json:"application_id"`
}

func (q *Queries) CreateApplicationRelease(ctx context.Context, arg CreateApplicationReleaseParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, createApplicationRelease,
		arg.Title,
		arg.VersionCode,
		arg.VersionName,
		arg.ReleaseNote,
		arg.Environment,
		arg.ApplicationID,
	)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getApplicationReleaseByID = `-- name: GetApplicationReleaseByID :one
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetApplicationReleaseByID(ctx context.Context, id pgtype.UUID) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, getApplicationReleaseByID, id)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLatestReleaseByEnvironment = `-- name: GetLatestReleaseByEnvironment :one
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE application_id = $1 AND environment = $2 AND deleted_at IS NULL
ORDER BY version_code DESC
LIMIT 1
`

type GetLatestReleaseByEnvironmentParams struct {
	ApplicationID pgtype.UUID        `json:"application_id"`
	Environment   ReleaseEnvironment `json:"environment"`
}

func (q *Queries) GetLatestReleaseByEnvironment(ctx context.Context, arg GetLatestReleaseByEnvironmentParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, getLatestReleaseByEnvironment, arg.ApplicationID, arg.Environment)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const hardDeleteApplicationRelease = `-- name: HardDeleteApplicationRelease :exec
DELETE FROM application_releases WHERE id = $1
`

func (q *Queries) HardDeleteApplicationRelease(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteApplicationRelease, id)
	return err
}

const listReleasesByApplication = `-- name: ListReleasesByApplication :many
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE application_id = $1 AND deleted_at IS NULL
ORDER BY version_code DESC
`

func (q *Queries) ListReleasesByApplication(ctx context.Context, applicationID pgtype.UUID) ([]ApplicationRelease, error) {
	rows, err := q.db.Query(ctx, listReleasesByApplication, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApplicationRelease{}
	for rows.Next() {
		var i ApplicationRelease
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.VersionCode,
			&i.VersionName,
			&i.ReleaseNote,
			&i.Environment,
			&i.ApplicationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByEnvironment = `-- name: ListReleasesByEnvironment :many
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE application_id = $1 AND environment = $2 AND deleted_at IS NULL
ORDER BY version_code DESC
`

type ListReleasesByEnvironmentParams struct {
	ApplicationID pgtype.UUID        `json:"application_id"`
	Environment   ReleaseEnvironment `json:"environment"`
}

func (q *Queries) ListReleasesByEnvironment(ctx context.Context, arg ListReleasesByEnvironmentParams) ([]ApplicationRelease, error) {
	rows, err := q.db.Query(ctx, listReleasesByEnvironment, arg.ApplicationID, arg.Environment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApplicationRelease{}
	for rows.Next() {
		var i ApplicationRelease
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.VersionCode,
			&i.VersionName,
			&i.ReleaseNote,
			&i.Environment,
			&i.ApplicationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteRelease = `-- name: PromoteRelease :one
UPDATE application_releases SET
    environment = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type PromoteReleaseParams struct {
	ID          pgtype.UUID        `json:"id"`
	Environment ReleaseEnvironment `json:"environment"`
}

// Change environment (e.g., development -> staging -> production)
func (q *Queries) PromoteRelease(ctx context.Context, arg PromoteReleaseParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, promoteRelease, arg.ID, arg.Environment)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteApplicationRelease = `-- name: SoftDeleteApplicationRelease :one

UPDATE application_releases SET
    deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

// ============================================================================
// Delete Queries
// ============================================================================
func (q *Queries) SoftDeleteApplicationRelease(ctx context.Context, id pgtype.UUID) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, softDeleteApplicationRelease, id)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateRelease = `-- name: UpdateRelease :one
UPDATE application_releases SET
    title = $2,
    release_note = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type UpdateReleaseParams struct {
	ID          pgtype.UUID `json:"id"`
	Title       string      `json:"title"`
	ReleaseNote pgtype.Text `json:"release_note"`
}

// Full update for title + release_note
func (q *Queries) UpdateRelease(ctx context.Context, arg UpdateReleaseParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, updateRelease, arg.ID, arg.Title, arg.ReleaseNote)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateReleaseNote = `-- name: UpdateReleaseNote :one
UPDATE application_releases SET
    release_note = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type UpdateReleaseNoteParams struct {
	ID          pgtype.UUID `json:"id"`
	ReleaseNote pgtype.Text `json:"release_note"`
}

func (q *Queries) UpdateReleaseNote(ctx context.Context, arg UpdateReleaseNoteParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, updateReleaseNote, arg.ID, arg.ReleaseNote)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateReleaseTitle = `-- name: UpdateReleaseTitle :one

UPDATE application_releases SET
    title = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type UpdateReleaseTitleParams struct {
	ID    pgtype.UUID `json:"id"`
	Title string      `json:"title"`
}

// ============================================================================
// Granular Update Queries
// ============================================================================
func (q *Queries) UpdateReleaseTitle(ctx context.Context, arg UpdateReleaseTitleParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, updateReleaseTitle, arg.ID, arg.Title)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
