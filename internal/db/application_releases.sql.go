// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: application_releases.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplicationRelease = `-- name: CreateApplicationRelease :one
INSERT INTO application_releases (
    title,
    version_code,
    version_name,
    release_note,
    environment,
    application_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type CreateApplicationReleaseParams struct {
	Title         string             `json:"title"`
	VersionCode   int32              `json:"version_code"`
	VersionName   string             `json:"version_name"`
	ReleaseNote   pgtype.Text        `json:"release_note"`
	Environment   ReleaseEnvironment `json:"environment"`
	ApplicationID pgtype.UUID        `json:"application_id"`
}

func (q *Queries) CreateApplicationRelease(ctx context.Context, arg CreateApplicationReleaseParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, createApplicationRelease,
		arg.Title,
		arg.VersionCode,
		arg.VersionName,
		arg.ReleaseNote,
		arg.Environment,
		arg.ApplicationID,
	)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getApplicationReleaseByID = `-- name: GetApplicationReleaseByID :one
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetApplicationReleaseByID(ctx context.Context, id pgtype.UUID) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, getApplicationReleaseByID, id)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLatestReleaseByEnvironment = `-- name: GetLatestReleaseByEnvironment :one
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE application_id = $1 AND environment = $2 AND deleted_at IS NULL
ORDER BY version_code DESC
LIMIT 1
`

type GetLatestReleaseByEnvironmentParams struct {
	ApplicationID pgtype.UUID        `json:"application_id"`
	Environment   ReleaseEnvironment `json:"environment"`
}

func (q *Queries) GetLatestReleaseByEnvironment(ctx context.Context, arg GetLatestReleaseByEnvironmentParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, getLatestReleaseByEnvironment, arg.ApplicationID, arg.Environment)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const hardDeleteApplicationRelease = `-- name: HardDeleteApplicationRelease :exec
DELETE FROM application_releases WHERE id = $1
`

func (q *Queries) HardDeleteApplicationRelease(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteApplicationRelease, id)
	return err
}

const listReleasesByApplication = `-- name: ListReleasesByApplication :many
SELECT id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at FROM application_releases 
WHERE application_id = $1 AND deleted_at IS NULL
ORDER BY version_code DESC
`

func (q *Queries) ListReleasesByApplication(ctx context.Context, applicationID pgtype.UUID) ([]ApplicationRelease, error) {
	rows, err := q.db.Query(ctx, listReleasesByApplication, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApplicationRelease{}
	for rows.Next() {
		var i ApplicationRelease
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.VersionCode,
			&i.VersionName,
			&i.ReleaseNote,
			&i.Environment,
			&i.ApplicationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteApplicationRelease = `-- name: SoftDeleteApplicationRelease :one
UPDATE application_releases SET
    deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

func (q *Queries) SoftDeleteApplicationRelease(ctx context.Context, id pgtype.UUID) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, softDeleteApplicationRelease, id)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateApplicationRelease = `-- name: UpdateApplicationRelease :one
UPDATE application_releases SET
    title = $2,
    release_note = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title, version_code, version_name, release_note, environment, application_id, created_at, updated_at, deleted_at
`

type UpdateApplicationReleaseParams struct {
	ID          pgtype.UUID `json:"id"`
	Title       string      `json:"title"`
	ReleaseNote pgtype.Text `json:"release_note"`
}

func (q *Queries) UpdateApplicationRelease(ctx context.Context, arg UpdateApplicationReleaseParams) (ApplicationRelease, error) {
	row := q.db.QueryRow(ctx, updateApplicationRelease, arg.ID, arg.Title, arg.ReleaseNote)
	var i ApplicationRelease
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VersionCode,
		&i.VersionName,
		&i.ReleaseNote,
		&i.Environment,
		&i.ApplicationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
